////////////////////////////////////////////////////////////////////////////////
// Filename: normalmap.ps
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
Texture2D shaderTextures[2];
SamplerState SampleType;

cbuffer LightBuffer
{
    float4 ambientColor;
    float4 diffuseColor;
    float3 lightDirection;
    float padding;
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 PS_Main(PixelInputType input) : SV_TARGET
{
    float4 color, out_ambient, out_diffuse;
    float4 textureColor;
    float4 normalMap;
    float3 bumpNormal;

    // Get data from textures.
    textureColor = shaderTextures[0].Sample(SampleType, input.tex);
    normalMap = shaderTextures[1].Sample(SampleType, input.tex);

    // Expand the range of the normal value from (0, +1) to (-1, +1).
    normalMap = (normalMap * 2.0f) - 1.0f;

    //calculate the normal from the normalMap
    bumpNormal = input.normal + (normalMap.x * input.tangent) + (normalMap.y * input.binormal);
    bumpNormal = normalize(bumpNormal);

     // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
    out_diffuse = saturate(diffuseColor* -dot(bumpNormal,lightDirection) );

    //set the default output color to the ambient light value
    out_ambient = ambientColor;

    // Calculate the amount of light on this pixel.
    color = saturate( out_ambient + out_diffuse);
    color = color*textureColor;

    return color;
}
